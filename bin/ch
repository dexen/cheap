#!/usr/bin/env php
<?php

function td(...$a) { foreach ($a as $v) var_export($v); echo "\n--\ntd()\n"; die(2); }

namespace dexen\Cheap;

require __DIR__ .'/' .'../lib/Cheap/libcheap.php';

switch ($argv[1]??null) {
case 'rev-parse':
	if ($argv[2] === 'HEAD') {
		$v = file_get_contents('.git/HEAD');
		$matches = [];
		if (preg_match('#^ref: (refs/heads/([^\\s]+))\\s*#', $v, $matches)) {
			$ref = $matches[1];
				# FIXME: prevent dir traversal outside
			$hash = rtrim(file_get_contents('.git/' .$ref));
			echo $hash, "\n";
			return 0; } }
	else {
		$short_hash = $argv[2];
		$a = repo_object_name_resolution_short_hash($short_hash);
		switch (count($a)) {
		case 1:
			echo $a[0], "\n";
			return 0;
		case 0:
			printf("Revision %s not found in repository\n", $short_hash);
			return 1;
		default:
			printf("Ambiguous revision %s\n", $short_hash);
			return 1; } }
case 'show':
	if ($argv[2] === 'HEAD') {
		$v = file_get_contents('.git/HEAD');
		$matches = [];
		if (preg_match('#^ref: (refs/heads/([^\\s]+))\\s*#', $v, $matches)) {
			$ref = $matches[1];
				# FIXME: prevent dir traversal outside
			$hash = rtrim(file_get_contents('.git/' .$ref));
			if (empty($hash)) {
				printf('Could not read hash of ref "%s"' ."\n", $ref);
				die(1); }
				pretty_print_blob(repo_object_content_by_hash($hash));
				die(0); }
		else {
			printf('Unsupported HEAD ref: "%s"' ."\n", $v);
			die(1); } }
	else {
		pretty_print_blob(repo_object_content_by_hash($argv[2]));
		die(0); }
case null:
	echo "USAGE: cheap show HEAD\n";
	die(0);
default:
	echo "USAGE: cheap show HEAD\n";
	die(1); }
